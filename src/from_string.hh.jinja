// autogenerated
#include <iostream>
#include <string>

template<typename T>
std::vector<std::pair<const char *, T>> enum_fields;

{% for enum in enums %}

template<>
constexpr std::array<std::pair<const char *, {{ enum.namespace }}::{{ enum.enum_name }}>, {{ enum.enum_fields|length }}> enum_fields<{{ enum.namespace }}::{{ enum.enum_name }}> = { {
    {% for f in enum.enum_fields %}
        {"{{ f }}", {{ enum.namespace }}::{{ enum.enum_name }}::{{ f }}},
    {% endfor %}
} };

{% if enum.namespace -%}
namespace {{ enum.namespace }} {

{% endif -%}

std::ostream& operator<<(std::ostream& os, const {{ enum.enum_name }}& e)
{
    switch (e) {
    {% for f in enum.enum_fields -%}
    case {{ enum.enum_name }}::{{ f }}:
        return os << "{{ f }}";
        break;
    {% endfor -%}
    }
    throw std::range_error("out of range value for {{ enum.enum_name }}");
}

std::istream& operator>>(std::istream& is, {{ enum.enum_name }}& e)
{
    const auto &m = enum_fields<{{ enum.enum_name }}>;

    std::string s;
    is >> s;
    const auto it = std::find_if(m.begin(), m.end(), [&s](const auto &v) { return v.first == s; });

    if (it == m.end()) {
        throw std::range_error("could not read {{ enum.enum_name }} from stream");
    }
    e = it->second;
    return is;
}

{%- if enum.namespace %}

}  // {{ enum.namespace }}
{%- endif %}

{% endfor %}
