// autogenerated

#pragma once

#include <iostream>
#include <array>
#include <string>

template<typename T>
size_t n_enum_fields;

template<typename T>
std::array<std::pair<const char *, T>, n_enum_fields<T>> enum_fields;

{% for enum in enums %}

{%- set n_fields = enum.fields | length -%}
{%- set full_name = enum.namespace + '::' + enum.name if enum.namespace else enum.name -%}

template<>
constexpr size_t n_enum_fields<{{ full_name }}> = {{ n_fields }};

template<>
constexpr std::array<std::pair<const char *, {{ full_name }}>, {{ n_fields }}> enum_fields<{{ full_name }}> = { {
    {% for f in enum.fields -%}
        {"{{ f }}", {{ full_name }}::{{ f }}},
    {% endfor -%}
} };

{% if enum.namespace -%}
namespace {{ enum.namespace }} {

{% endif -%}

std::ostream& operator<<(std::ostream& os, const {{ enum.name }}& e)
{
    switch (e) {
    {% for f in enum.fields -%}
    case {{ enum.name }}::{{ f }}:
        return os << "{{ f }}";
        break;
    {% endfor -%}
    }
    throw std::range_error("out of range value for {{ enum.name }}");
}

std::istream& operator>>(std::istream& is, {{ enum.name }}& e)
{
    const auto &m = enum_fields<{{ enum.name }}>;

    std::string s;
    is >> s;
    const auto it = std::find_if(m.begin(), m.end(), [&s](const auto &v) { return v.first == s; });

    if (it == m.end()) {
        throw std::range_error("could not read {{ enum.name }} from stream");
    }
    e = it->second;
    return is;
}

{%- if enum.namespace %}

}  // {{ enum.namespace }}
{%- endif %}
{% endfor %}
